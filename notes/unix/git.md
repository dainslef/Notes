- [Git 配置](#git-配置)
	- [配置文件](#配置文件)
- [版本操作](#版本操作)
	- [创建版本库](#创建版本库)
	- [提交改动](#提交改动)
	- [重命名版本库中的文件](#重命名版本库中的文件)
	- [修改历史提交说明](#修改历史提交说明)
	- [忽略工作目录中特定文件](#忽略工作目录中特定文件)
	- [查看/比较提交](#查看比较提交)
	- [提交管理](#提交管理)
	- [标签管理](#标签管理)
	- [查看文件改动](#查看文件改动)
	- [分支管理](#分支管理)
	- [暂存变更](#暂存变更)
- [远程仓库](#远程仓库)
	- [拷贝远程仓库](#拷贝远程仓库)
	- [管理远程仓库](#管理远程仓库)
	- [管理远程分支](#管理远程分支)
		- [分支合并规则](#分支合并规则)
		- [创建/删除远程分支](#创建删除远程分支)
		- [强制覆盖远程分支内容](#强制覆盖远程分支内容)
- [GitHub 配置](#github-配置)
	- [创建 GitHub 仓库](#创建-github-仓库)
	- [生成 SSH 本地密钥](#生成-ssh-本地密钥)
	- [推送本地分支](#推送本地分支)
	- [关于提交者](#关于提交者)
- [清理提交](#清理提交)



# Git 配置
在使用`Git`之前，首先要设置用户的**全局用户名**和**邮箱**，做为代码提交者的身份标识。

```
$ git config --global user.name [用户名]
$ git config --global user.email [邮箱]
```

设置Git的默认编辑器：

```
$ git config --global core.editor [编辑器名称]
```

设置Git的远程推送方式：

```
$ git config --global push.default [推送选项]
```

**推送选项**在`Git 2.0`之后默认为`simple`，之前为`matching`。
推送选项取值含义：

- `current`、`simple` 推送当前分支到远程关联的同名分支。
- `matching` 推送与远程仓库具有的分支中所有与本地仓库分支同名的本地分支。

设置`Git`换行符处理方式：

```
$ git config --global core.autocrlf [换行符处理方式]
```

**换行符选项**取值含义：

- `true`

	在`Windows`提交到`Unix`环境时使用。
	提交时将`CRLF`转换为`LF`，而签出代码时自动将`LF`转换为`CRLF`。

- `input`

	在`Unix`环境中使用。
	提交时`CRLF`换行符转换为`LF`，而签出代码时`LF`不转换为`CRLF`。

- `false`

	在`Windows`环境中使用，不转换`CRLF`，直接提交。

## 配置文件
`Git`配置文件分为**全局配置文件**和**仓库配置文件**。

- 仓库配置文件：

	仓库配置文件路径为`[仓库路径]/.git/config`，使用`git config`指令会将配置写入此文件。

- 全局配置文件：

	全局配置文件路径为`~/.gitconfig`。

	- 在`Linux/*BSD`中，家目录为`/home/[用户名]`。
	- 在`macOS`中，家目录为`/Users/[用户名]`。
	- 在`Windows`中，家目录为为`C:\Users\[用户名]`。

	使用`git config --global`指令会将配置写入此文件中。
	全局配置的优先级**低于**当前仓库的配置，当前仓库的配置与全局配置不一致时会**覆盖**全局配置。



# 版本操作
如同其它版本控制工具一样，使用Git能够方便地进行版本的**提交**、**回滚**、**比较**等操作。

## 创建版本库
选择一个可用的空目录作为源码仓库，执行指令将此目录初始化为版本库：

```
$ git init
```

指令成功指令后目录下会多出一个名为`.git`的目录，该目录记录了版本库的各种信息，不要随意修改。

## 提交改动
向版本库提交改动需要以下几个步骤：

1. 添加有改动的文件：

	```
	$ git add [文件路径]
	```

1. 执行提交操作：

	```
	$ git commit
	```

如果进行了错误的操作，在提交之前，可以放弃缓冲区的更改：

```
$ git reset
```

在提交时可一同添加提交说明，使用：

```
$ git commit -m [提交说明]
```

如果需要修改提交说明，使用命令修改最近一次的提交说明：

```
$ git commit --amend
```

还可以修改最近一次的提交者信息：

```
$ git commit --amend --author="用户名 <邮箱>"
```

## 重命名版本库中的文件
版本库中的文件**不能**直接使用Unix的`rm`、`mv`等命令进行操作。
使用`mv`重命名文件后，`Git`会认为原文件在版本库中被**删除**了，原文件的在版本库内的记录不会继续到重命名后的新文件上。

在版本库内重命名文件应使用`Git`提供的指令：

```
$ git mv [源文件名] [新文件名]
```

## 修改历史提交说明
要修改历史版本的提交说明，首先要重构目标提交说明所在的提交的前一次提交。

修改历史提交说明，需要执行以下步骤：

1. 执行`git rebase -i [commit_id]`，之后会进入交互式的历史提交查看页面，在这个页面将要修改的提交说明前的`pack`字段改为`edit`。
1. 字段修改完毕后，`Git`会自动支跳转到该次提交，执行`git commit --amend`像往常提交了错误的提交说明一样修改提交说明。
1. 之后重新构建提交，执行`git rebase --continue`，`Git`又会重新跳转到最近的提交，历史提交说明修改完成。

## 忽略工作目录中特定文件
默认配置下，Git会将工作目录中的**所有文件**视为目标文件，一旦出现新增文件，便会给予提示(存在尚未跟踪的文件)。

查看当前暂存区的状态：

```
$ git status
```

要想让Git忽略某些文件，可以在工作目录中创建`.gitignore`文件，将忽略文件的文件名分行写入其中(一行一个文件名)：

- `.gitignore`文件内的忽略文件支持`Unix`文件名匹配规则，可以使用`*`、`?`等操作符匹配多个文件名。
- `.gitignore`文件自身也可加入到忽略列表中。

查看到文件状态，使用命令：

```
$ git status -s
```

`??`符号代表未跟踪的文件。

## 查看/比较提交
使用`git show`指令可查看提交中具体的变更内容。

查看最近提交的改动详情：

```
$ git show
```

查看某个提交的改动详情：

```
$ git show [commit_id/标签名]
```

比较文件当前状态与版本库中的区别：

```c
$ git diff //该命令可以看到当前文件与最近一次的提交版本有哪些区别
```

比较不同版本/分支：

```c
$ git diff [commit_id] //将当前版本与指定commit进行比较
$ git diff [commit_id1] [commit_id2] //将两个commit版本进行比较
$ git diff [分支名1] [分支名2] //将两个分支进行比较
```

## 提交管理
使用`git log`查看提交历史：

```c
// 交互式查看版本库的历史提交记录和commit_id
$ git log

// 仅仅查看提交的commit_id
$ git log --pretty=oneline
```

根据每次提交的`commit_id`回滚到历史版本：

```c
// 回滚到指令版本，该版本之后的文件改动变为待提交状态
$ git reset [commit_id]

// 回滚到指令版本同时完全清除该版本之后的文件变化
$ git reset --hard [commit_id]
```

回退到历史版本之后，将不能在`git log`指令中看到自回退版本之后的`commit_id`。
若需要之后版本的`commit_id`，执行指令：

```
$ git reflog
```

## 标签管理
使用`git tag`相关指令给历史提交添加**标签**：

```c
// 给最近一次提交的版本添加版本标签(默认版本标签说明为空)
$ git tag [标签名]

// 添加版本标签同时添加标签说明
$ git tag [标签名] -m [版本说明]

// 给指定某次提交添加版本标签
$ git tag [标签名] [commit_id]

// 删除指定标签
$ git tag -d [要删除的标签名]
```

## 查看文件改动
使用`git log`指令指定文件路径时可以查看指定文件的改动。

```c
// 查看具体某一个文件的历史改动
$ git log [文件名]

// 查看文件改动同时显示具体变更内容
$ git log -p [文件名]
```

## 分支管理
Git提供了完整的分支管理功能。

使用`git branch`相关指令查看、管理分支：

```c
// 查看本地分支
$ git branch

// 查看所有分支(包括远程分支)
$ git branch -a

// 删除指定本地分支(未完全合并的分支不会被删除)
$ git branch -d [分支名称]

// 强制删除指定分支
$ git branch -D [分支名称]

// 删除指定远程分支
$ git branch -rd [远程分支名称]

// 重命名分支
$ git branch -m [原分支名称] [新分支名称]
```

使用`git branch -a`查看远程分支时，远程分支名称以`remotes/`为起始路径。
删除远程分支时，应以`remotes/`之后的部分作为分支名称，如下所示：

```
$ git branch -a //查看所有分支
* dev
  master
  remotes/GitHub/dev
$ git bracch -rd remotes/GitHub/dev //删除失败，分支名称未找到
error: remote-tracking branch 'remotes/GitHub/dev' not found.
$ git branch -rd GitHub/dev //删除远程分支时应忽略 remotes 前缀
```

使用`git checkout`相关指令切换分支：

```c
// 切换到指定分支
$ git checkout [分支名]

// 创建分支并切换到该分支
$ git checkout -b [分支名]
```

使用`git merge`合并分支：

```c
// 合并某分支到当前分支
$ git merge [分支名]
```

## 暂存变更
当修改了工作区中的文件，尚未提交，而远程仓库中此文件同样有改动时，将远程仓库`pull`到本地会提示文件冲突。

1. 使用`git stash`将本地修改暂存。
1. 使用`git stash`之后，工作区会恢复到最近一次提交，所有的改动都被保存，工作区重新变为`clear`。
1. 再次进行`pull`操作，将远程仓库拉取到本地。
1. 最后运行`git stash pop`将之前暂存的改动重新应用到当前工作区。



# 远程仓库
Git的远程仓库服务基于`SSH`，因此远程仓库的主机上必须安装并启动了**SSH服务**。
远程仓库的地址需要符合SSH地址的规范，即写成`ssh://用户名@ip地址/绝对路径`的形式。

## 拷贝远程仓库
使用SSH协议复制目标主机的指定仓库：

```
$ git clone [SSH地址]
```

## 管理远程仓库
使用`git remote`相关指令可以进行远程仓库的相关操作。

远程仓库的地址需要是一个有效的`URL`，创建远程仓库：

```
$ git remote add [远程仓库名] [远程仓库地址]
```

例如，执行指令`git remote add NetRepo ssh://root@192.168.1.199/root/Notes`即创建了一个目标主机地址为`192.168.1.199`、用户为`root`、仓库地址为目标主机的`/root/CodeNotes`目录的远程仓库。

其它远程仓库操作指令：

```c
// 列出所有的远程仓库
$ git remote

// 查看某个远程仓库的具体信息
$ git remote show [远程仓库名称]

// 重命名远程仓库
$ git remote rename [旧仓库名称] [新仓库名称]

// 删除远程仓库
$ git remote remove [远程仓库名称]
```

## 管理远程分支
使用`git push/pull`指令进行远程分支的同步相关操作。

使用`git push`推送本地分支。
在执行推送操作之前，需要保证本地分支与远程分支**无冲突**，否则会推送失败。
推送一个本地分支到远程仓库的指定远程分支上：

```
$ git push [远程仓库名] [本地分支名称]:[远程分支名称]
```

当本地分支与远程分支存在差异时，需要先使用`git pull`指令合并远程分支，之后再进行推送操作。
接收远程分支更新并进行合并：

```
$ git pull [远程仓库名] [远程分支名称]
```

若本地仓库与远程仓库存在**同名分支**，则可以简写为：

```
$ git push [远程仓库名] [同名分支]
```

### 分支合并规则
默认Git会将远程仓库推送的分支与本地仓库的同名分支进行合并。

`git pull`实际相当于两次操作：

1. `$ git fetch [远程仓库名]`
1. `$ git merge [远程仓库名/分支名称]`

在特定情况下可以简化同步命令参数。
若设置了追踪关系，则可以省略远程分支名：

```
$ git pull [远程仓库名]
```

若存在唯一的追踪关系，则可以省略所有参数：

```
$ git pull
```

追踪关系可以手动设定：

```
$ git branch --set-upstream [本地分支] [远程仓库名/远程分支名]
```

### 创建/删除远程分支
推送本地分支到一个不存在的远程分支上，会在远程仓库上创建该分支：

```
$ git push [远程仓库名] [本地分支名称]:[要创建的远程分支名称]
```

若推送**空本地分支**给对应远程仓库的指定分支，则会删除远程仓库的指定分支：

```
$ git push [远程仓库名] :[远程分支名称]
```

在`Git 1.7`之后提供了删除远程分支的参数，作用相同：

```
$ git push [远程仓库名] --delete [远程分支名称]
```

### 强制覆盖远程分支内容
强制覆盖分支的内容需要修改远程仓库中的`receive`配置：

```
$ git config receive.denyCurrentBranch ignore
```

同时，本机在执行`push`操作时使用`--force`参数：

```
$ git push [远程仓库名] [同名分支] --force
$ git push [远程仓库名] [本地分支名称]:[远程分支名称] --force
```

若未使用`--force`参数，分支内容合并有冲突时依旧会拒绝合并而非强制覆盖。



# GitHub 配置
`GitHub`是一个当下流行的提供免费`Git`仓库托管服务的网站。本地的`Git`仓库可以方便地托管到`GitHub`上。

## 创建 GitHub 仓库
注册完`GitHub`帐号之后，在`Repositories`页面中即可创建`GitHub`个人仓库。

## 生成 SSH 本地密钥
`GitHub`支持多种传输协议，若使用`SSH`协议，则需要在本地生成SSH的**公钥**和**私钥**。

使用`ssh-keygen`命令生成密钥：

```
$ ssh-keygen -t rsa -C [GitHub邮箱名称]
```

生成密钥的过程中会有选项，全部回车默认即可。
命令执行结束之后会在本地家目录下的`.ssh`文件夹下生成两个密钥文件：`id_rsa`和`id_rsa.pub`。

将公钥`id_rsa.pub`中的内容复制到`GitHub`个人设置中的`SSH keys`页面中。
私钥存放在需要进行提交操作的主机上(执行提交操作的主机不需要公钥)。

`id_rsa`以及`id_rsa.pub`文件的权限必须设置为**仅当前用户可见**(`600`)。
若密钥文件其他用户、用户组可见则无法完成同步操作。

只有使用`SSH`协议时需要设置密钥，若使用`HTTP`协议则不需要。
使用`HTTP`协议推送时会要求输入密码以确认提交者身份。

## 推送本地分支
推送本地分支到远程仓库，执行以下步骤：

1. 在本地添加远程GitHub仓库地址：

	添加完密钥之后，查看已创建的仓库的地址，将此地址添加到远程仓库中。
	例如，以`GitHub`作为远程仓库的名称，当前仓库为地址，即输入指令：

	```
	$ git remote add GitHub git@github.com:dainslef/Notes.git
	```

1. 远程仓库添加完毕后，即可使用`git push`指令推送本地分支到GitHub仓库中。

## 关于提交者
本地`.gitconfig`文件中的邮箱最好设置成与**GitHub账户**邮箱相同，否则头像等信息不会在`GitHub`的提交界面显示出来。

只有本地提交邮箱与**GitHub账户**设置的邮箱相同时，才会被认为是当前账户的操作。



# 清理提交
使用`git reset --hard`强制恢复到某个提交后，在该提交之后的提交记录并不会被删除，使用`git reflog`指令依然能够看到之后`commit id`，但这些提交不在与当前分支关联。

经常性使用`git reset --hard`变更提交记录，会在仓库中生成大量未与分支关联的提交记录，会占用不必要的磁盘空间。

清理所有位于分支关联的提交记录，执行以下步骤：

1. 清除分支变更历史。

	```
	$ git reflog expire --expire=now --all
	```

1. 压缩到目前为止的历史提交信息。

	```
	$ git gc --prune=now
	```

执行以上操作之后，使用`git reflog`指令，会发现历史变更记录已被清空，所有未与分支联的提交信息都已被清理。
