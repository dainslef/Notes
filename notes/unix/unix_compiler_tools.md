<!-- TOC -->

- [编译流程](#编译流程)
	- [*Preproceessing* 预处理](#preproceessing-预处理)
	- [*Compilation* 编译](#compilation-编译)
	- [*Assembly* 汇编](#assembly-汇编)
	- [*Linking* 链接](#linking-链接)
- [编译器](#编译器)
	- [基本编译操作](#基本编译操作)
	- [库文件](#库文件)
	- [符号信息](#符号信息)
	- [反汇编](#反汇编)
	- [*otool*](#otool)
	- [头文件/库文件路径](#头文件库文件路径)
	- [优化级别](#优化级别)
	- [其它编译器参数](#其它编译器参数)
- [*Objective-C* 编译](#objective-c-编译)
	- [环境安装](#环境安装)
	- [编译参数](#编译参数)

<!-- /TOC -->



## 编译流程
编译器处理代码简单得来说分为以下几个阶段：

1. `Preprocessing` 预处理
1. `Compilation` 编译
1. `Assembly` 汇编
1. `Linking` 链接

### *Preproceessing* 预处理
主要处理包括以下过程：

1. 将所有的`#define`删除，并且展开所有的宏定义
1. 处理所有的条件预编译指令，比如`#if`、`#ifdef`、`#elif`、`#else`、`#endif`等
1. 处理`#include`预编译指令，将被包含的文件插入到该预编译指令的位置
1. 删除所有**注释**`//`和`/* */`
1. 添加**行号**和**文件标识**，以便编译时产生调试用的行号及编译错误警告行号
1. 保留所有的`#pragma`编译器指令，因为编译器需要使用它们

预处理之后得到`*.i`的源码文件。

### *Compilation* 编译
编译过程就是把预处理完的文件进行一系列的**词法分析**、**语法分析**、**语义分析**及优化后生成相应的汇编代码。

编译之后得到`*.s`的汇编源码文件。

### *Assembly* 汇编
汇编器是将汇编代码转变成机器可以执行的命令，每一个汇编语句几乎都对应一条机器指令。  
汇编相对于编译过程较简单，根据汇编指令和机器指令的对照表一一翻译。

汇编之后得到`*.o`的**目标文件**，内容为**机器码**，不能以普通文本形式的查看(用文本编辑器查看则内容为乱码)。  
`Linux/Unix`环境下的汇编器为`as`。

### *Linking* 链接
链接程序运行需要的目标文件，以及所依赖的其它库文件，最后生成可执行文件。  
`Linux/Unix`环境下的链接器为`ld`。



## 编译器
在`Unix`环境下，常用的编译器为`gcc/clang`。二者的提供类似的命令行接口。

### 基本编译操作
编译源码的基本命令(一次性执行预处理、编译、汇编、链接等所有过程，直接得到可执行文件)：

```
$ cc [c源码文件] //cc为c语言编译器
$ c++ [c++源码文件] //c++为c++编译器
```

不同的操作系统中对`cc`编译器的实现**不同**。  
一般情况下，`cc`指令是一个软链接，指向系统默认的编译器，即使用cc编译器实际调用的是操作系统的默认编译器：

- 在`Linux`中，`cc`软链接指向`gcc`编译器。
- 在`FreeBSD/macOS`中，`cc`软链接指向`clang`编译器。
- 在`Solaris`中，`cc`指令不再是软链接，而是`Solaris`特有的商业闭源编译器。

默认情况下，编译器会生成一个名为`a.out`的二进制可执行文件，运行程序：

```
$ ./a.out
```

若需要指定生成可执行文件的名称，则需要使用`-o`参数：

```
$ cc [源码文件] -o [指定执行文件的名称]
```

若仅需要编译器进行预处理，则需要使用`-E`参数：

```
$ cc -E [源码文件]
```

默认情况下，编译器会将预处理的结果直接输出到终端上，若需要将预处理结果输出到文件中，使用(保存预处理后代码的文件一般用`*.i`做后缀名)：

```
$ cc -E [源码文件] -o [预处理结果文件名(*.i)]
```

若需要得到编译器生成的汇编代码可以使用`-S`参数：

```
$ cc -S [源码文件]
```

默认情况下生成`AT&T`风格的汇编，若需要生成`intel`风格的汇编可以使用参数：

```
$ cc -S -masm=intel [源码文件]
```

若不需要直接生成可执行文件，仅生成`*.o`格式的目标文件，则需使用`-c`参数：

```
$ cc -c [源码文件]
```

默认情况下，编译器不会在生成的执行文件中添加调试标记，若需要在生成的二进制文件中保留调试标记，需要使用`-g`参数：

```
$ cc -g [源码文件]
```

使用`-g`参数生成的可执行文件会包含调试标记，可供`gdb`等调试器使用：

```
$ gdb [生成的可执行文件]
```

使用`-s`参数则生成可执行文件中的不包含符号表(不包含符号表的可执行文件体积更小，适合在发布软件时使用)：

```
$ cc -s [源码文件]
```

使用`-D`参数可在编译时添加宏定义，搭配`#ifdef/ifndef`等条件宏指令可实现在编译时改变程序逻辑的效果。  
假设有源码文件`test.c`，内容如下所示：

```c
#include <stdio.h>

int main(void)
{

#ifdef __TEST__
	printf("Use macro __TEST__.");
#else
	printf("Dont't use macro.");
#endif

	return 0;
}
```

使用指令`cc test.c`编译，输出结果：

```
Dont't use macro.
```

使用指令`cc -D__TEST__ test.c`编译，输出结果：

```
Use macro __TEST__.
```

### 库文件
在Unix环境中，系统的库文件一般存放在`/lib`、`/lib64`、`/usr/lib`等路径下，库文件分为以下两种类型：

- **动态链接库**，后缀名为`so`意为`share object`(共享对象)。
- **静态库**，后缀名为`a`意为`archive`(档案文件)。

在Unix环境中，库的命名方式一般为`lib+[库名]`，如动态库名称为`libssl.so`，则链接时的库名称为`ssl`。  
使用`ldd`命令可以查看可执行文件链接了哪些动态链接库：

```
$ ldd [可执行文件]
```

- 连接库文件

	在编译时如果需要使用链接库，需要`-l`参数直接加**库名**而不需要写完整的库文件名字：
	
	```
	$ cc [源码文件] -l[库名]
	```
	
	若库的位置不在环境变量中，则需要用`-L`参数指定库所在路径：
	
	```
	$ cc [源码文件] -L[库所在路径] -l[库名]
	```
	
	若源码中引用的头文件位置不在环境变量中，则需要用`-I`参数手动指定头文件所在路径：
	
	```
	$ cc [源码文件] -I[头文件路径]
	```
	
	编译器在链接库时优先使用动态链接库，若需使用静态链接，使用`-static`参数强制编译器使用静态库：
	
	```
	$ cc -static [源码文件] -l[库名]
	```

	连接目标文件(*.o)和库时使用`ld`命令：

	```
	$ ld [目标文件] -l[库名]
	```

- 生成库文件

	动态链接库可以由编译器生成：
	
	```
	$ cc -shared -fPIC [源码文件] -o [生成动态库的名字]
	```
	
	静态库使用`ar`指令创建。  
	需要先将源码编译成目标文件，再使用`ar`命令：
	
	```
	$ ar crs [生成静态库的名称] [目标文件]
	```

	也可使用`libtool`工具生成动态库和静态库。

- 库文件环境变量

	如果一个程序使用了非系统提供的动态链接库，需要将自己的动态链接库位置加入环境变量中，否则在运行程序时会提示找不到	动态链接库。
	
	与`Windows`不同，`Linux/Unix`系统默认情况下不会在可执行文件所处的路径中寻找动态链接库。  
	若需要可执行文件加载当前路径下的动态库，则需要将当前路径加入`LD_LIBRARY_PATH`环境变量中：
	
	```
	$ export LD_LIBRARY_PATH=./
	```
	
	需要注意的是，该命令会在`logout`之后失效，长期使用可已考虑写入`.xprofile`或`.profile`文件中。  
	静态链接库由于在编译阶段已经将库文件包含在可执行文件中，故不会出现类似问题。

### 符号信息
使用`nm`命令可以显示二进制文件的符号信息(符号表)：

```
$ nm [可执行文件]
```

`nm`指令的常用参数：

- `-A` 在每个符号信息的前面打印所在对象文件名称
- `-C` 输出解码过的符号名称，能够以易于理解的方式显示`C++`函数名
- `-D` 打印动态符号
- `-l` 使用对象文件中的调试信息打印出所在源文件及行号
- `-n` 按照地址/符号值来排序
- `-u` 打印出那些未定义的符号

常见的符号类型：

- `A` 该符号的值在今后的链接中将不再改变
- `B` 该符号放在BSS段中，通常是那些未初始化的全局变量
- `D` 该符号放在普通的数据段中，通常是那些已经初始化的全局变量
- `T` 该符号放在代码段中，通常是那些全局非静态函数
- `U` 该符号未定义过，需要自其他对象文件中链接进来
- `W` 未明确指定的弱链接符号，同链接的其他对象文件中有它的定义就用上，否则就用一个系统特别指定的默认值

### 反汇编
在`Linux`下，使用`objdump`工具可以对`ELF`二进制文件进行反汇编，以`ArchLinux`为例，安装`objdump`：

```
# pacman -S binutils
```

`objdump`工具的常见参数：

- `-a` 查看档案文件(`*.a`静态库)的详细信息
- `-C` 将底层符号名解码成用户级名称，让`C++`函数名以能够被理解的方式显示出来
- `-d` 查看二进制文件的反汇编代码
- `-D` 查看二进制文件的反汇编代码，包括所有`section`
- `-g` 显示调试信息
- `-e` 显示调试信息，生成的信息格式与`ctags`兼容
- `-r` 显示文件的重定位入口，只能用于静态库
- `-R` 显示文件的动态重定位入口，用于动态链接库和可执行文件
- `-s` 以16进制形式查看可执行文件内容

### *otool*
在`macOS`下，二进制格式为`Mach-O`，`macOS`没有提供`objdump`、`ldd`等工具。

使用`otool`工具代替`objdump`进行反汇编：

```
$ otool -Vt [二进制文件]
```

使用`otool`工具代替`ldd`显示文件链接了哪些动态库：

```
$ otool -L [二进制文件]
```

### 头文件/库文件路径
编译时gcc会自动包含一些常规系统头文件路径，如`/usr/include`；以及一些常规的系统库路径，如`/usr/lib`。

若需要追加包含自定义头文件路径，应使用`-I`编译参数；  
追加包含自定库文件路径，应使用`-L`编译参数。

若需要添加系统头文件路径，可设置以下环境变量：

- `C_INCLUDE_PATH` `gcc`附加头文件路径
- `CPLUS_INCLUDE_PATH` `g++`附加头文件路径
- `LD_LIBRARY_PATH` 附加库文件路径

`gcc/g++`会将对应环境变量下的路径视为附加的系统头文件/库文件路径，不必每次使用`-I/-L`参数显式添加。

使用`--sysroot`参数可以重设头文件/库文件的逻辑根目录，使用此参数，默认的头文件/库文件路径均会随之改变。  
如设定`--sysroot=dir`，则默认头文件路径变为`dir/usr/include`，默认库文件路径变为`dir/usr/lib`。

### 优化级别
在编译程序时，可以为程序添加代码优化选项来提升程序的运行效率。

`GCC/Clang`有`O1`、`O2`、`O3`三个代码优化级别，`O1`最低，`O3`优化最高。  
使用优化选项能大幅度提升生成二进制文件的执行效率，但会使得生成的程序难以调试。故一般只在程序完成测试之后进入发布阶段才会启用编译优化选项。

### 其它编译器参数
其它常用的编译器参数如下：

- `-W` 警告选项，常用的是`-Wall`，开启所有警告。
- `-M` 将文件依赖关系输出到标准输出，输出的文件依赖可以被构建工具`make`使用。
	1. `-M` 默认会输出所有的头文件路径，包括`#include<>`和`#include""`。
	1. `-MM` 仅输出`#include""`的头文件路径。
	1. `-MD` 将依赖关系输出重定向到依赖关系文件`[文件名].d`，通常与`-M`或`-MM`一同使用。



## *Objective-C* 编译
主流的编译器同样支持`Objective-C`语言，`Objective-C`语言的源码为`*.m`。

### 环境安装
要让编译器顺利的编译`Objective-C`的源码，需要安装对应开发库，在Linux系统中是`GNUstep`库。

使用`GCC`编译`Objective-C`源码，需要安装`GCC`的`Objective-C`支持包`gcc-objc`。  
以`ArchLinux`为例，安装`Objective-C`开发环境：

```
# pacman -S gcc-objc gnustep-core
```

### 编译参数
编译`Objective-C`的源码相对编译C/C++源码而言要更复杂，需要使用更多的编译器参数。

使用`gnustep-config --objc-flags`指令会自动生成编译`Objective-C`源码需要的编译器参数，将指令的结果插入`gcc`编译指令的参数中。  
一般情况下，需要链接`libgnustep-base`、`libobjc`这两个库，如果源码使用了GUI库还需要链接`libgnustep-gui`库。

`GCC`编译`Objective-C`源码指令：

```
$ gcc $(gnustep-config --objc-flags) -lobjc -lgnustep-base [源码文件]
```

由于`gnustep-config`默认与`GNU编译器`组搭配，故其生成的编译参数并不完全适用于`Clang`编译器。  
需要手动指定编译参数以符合`Clang`编译器的要求，根据编译器输出的异常信息将`gnustep-config`指令生成的参数中不符合要求的参数剔除，并加入其他需要的编译器参数。

`Clang`编译`Objective-C`源码指令(以`Archlinux x64`和`gcc 4.9.2`为例)：

```
$ clang -fconstant-string-class=NSConstantString -lgnustep-base -lobjc -I/usr/lib/gcc/x86_64-unknown-linux-gnu/[gcc-version]/include [源码文件]
```
