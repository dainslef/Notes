<!-- TOC -->

- [類型系統](#類型系統)

<!-- /TOC -->



# 類型系統
編程語言根據其類型系統的特徵，可按多個緯度進行劃分、歸類：

- `Static Typing`(靜態類型) & `Dynamic Typing`(動態類型)

	靜態類型語言中，類型在**編譯期間**確定。
	靜態類型語言的類型結構**不能**在運行期間修改(例如向實例中動態添加/刪除類型的字段/方法)，類型結構一經定義就已確定。
	靜態類型語言多數需要使用**編譯器**將源碼編譯爲特定的目標代碼後執行，在編譯期間，編譯器能夠檢查出類型相關的錯誤。
	部分靜態類型語言擁有`Reflect`(反射)特性(如`Java`、`C#`、`Go`等)，具有一定的動態特性，能夠在運行期間獲取類型信息，修改成員內容。

	動態類型語言中，類型在**運行時**確定。
	動態類型語言的類型結構**可以**在運行時修改，類型系統更加靈活。
	動態語言多數採用解釋執行的方式，僅在運行期間才能發現類型錯誤。

	常見的靜態類型語言：

	```
	C/C++、Java、Go、Rust、Scala、Haskell
	```

	常見的動態類型語言：

	```
	Python、Ruby、JavaScript
	```

- `Strong Typing`(強類型) & `Weak Typing`(弱類型)

	強類型語言中，運行時**不會**將實例自動轉化爲與實際內容不符的類型。
	弱類型語言中，運行時會將實例自動轉化爲與實際內容不符的類型，自動轉化實際改變了實例的實際內容。

	常見的強類型語言：

	```
	Java、Scala、Haskell、Python
	```

	常見的弱類型語言：

	```
	C、Assembly、JavaScript
	```

- `Latent (Implicit) Typing`(隱式類型) & `Manifest (Explicit) Typing`(顯式類型)

	顯式類型語言需要在源碼中爲顯式地爲字段、方法標註類型信息。
	隱式類型語言不需要顯式標註類型信息，編譯器、解釋器可從上下文中推斷出字段、方法的類型。

	部分隱式類型語言可選則手動添加類型標註，用於在類型推斷不準確或無法進行的情況下的顯式添加類型信息。
	部分顯式類型語言在新版本中也添加了自動類型推導機制，如`C++ 11`、`C# 3.0`等。

	常見的隱式類型語言：

	```
	Python、Ruby、JavaScript、Haskell
	```

	常見的顯式類型語言：

	```
	C、C++、C#、Java
	```

- `Nominal Typing`(名義類型) & `Structural Typing`(結構類型)

	名義類型語言在判定類型時根據類型的標稱(類型名稱)。
	結構類型語言在判定類型時根據類型的實際結構。

	對於名義類型的語言而言，兩個結構完全相同的類型只要名稱不同，便不是同一個類型；
	而結構類型語言僅需要實際結構相同即可。

	動態語言中常見的`Duck Type`(鴨子類型)特性即是結構類型的特徵。
	部分名義類型語言也會帶有結構類型的特性，如Go中的`Interface`、C++中的`Template`、Scala中的`Structural Type`等。

	常見的名義類型語言：

	```
	C、C++、C#、Java、Scala
	```

	常見的結構類型語言：

	```
	Python、Ruby、Haskell
	```
